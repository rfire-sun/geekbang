1.（必做）分别用 100 个字以上的一段话，加上一幅图（架构图或脑图），总结自己
对下列技术的关键点思考和经验认识:

JVM
NIO
并发编程
Spring 和 ORM 等框架
MySQL 数据库和 SQL
分库分表
RPC 和微服务
分布式缓存
分布式消息队列
要求提交毕业项目 + 毕业总结，毕业总结写在 README 文件里即可。



## JVM

JVM（Java virtual Machine）Java虚拟机

是工作在各个操作系统上的一个虚拟的计算机，由sun公司（现已被Oracle公司收购）**以下统称oracle公司**提供，由sun公司提供各个版本的JVM为Java程序员提供了一种一次编译，多次运行的跨平台方案（class二进制文件跨平台）

具体工作表现在我们在Windows编写的代码可以直接在Linux上编译执行，或者直接用class文件在linux平台上执行

oracle提供JDK（Java Development kit）供我们在JVM上构建Java应用

JVM发展到如今由非常多的版本，比较经典的版本由Java6，Java8，目前最新的长期支持版式Java17



所有Java应用的入口都是main方法，JVM加载代码都是加载字节码文件，对于我们应用程序员来说，主要关心的就是Java代码就行了

个人不太纯熟的想法部分

**所有的软件都是数据结构与算法**，Java语言满足图灵完备性，个人感觉这是工程上的产物，对应的一个名词叫做**技术**，相对于其他语言来说，Java提供了跨平台的特性加上多种垃圾回收机制，并且是一种面向对象编程的语言，可以让程序员的编写在工程上更少的关注细节，更少的出错，更关心实际的业务，更加效率的创造生产力，这是现在的一个理解



学习JVM现在看来有两个主要目的

1，了解我们目前编程的时候在JVM这一层的原理，做到JVM层面的知其然而知其所以然

2，学习内存模型和相关的问题排查工具和经验，可以帮助我们在实际上遇到JVM调优，JVM相关问题排查的时候不至于一脸懵

按照目前理解的JVM重要程度（自己的理解，实际的经验所得，自己理解自己个人并没有进行比较深层次的思考）从大到小排列为1：JVM内存模型，2：JVM相关的内置命令行和调试工具，3：CMS GC，parallel GC，串行GC相关，4：JVM类加载器，5：JVM参数相关，6：Java字节码相关



JVM模型式所有GC的基础，JVM都是基于分代假设

JVM相关内置工具式所有JDK都有的工具，熟练以后再日后进行调试的时候都会有用

特定GC特点可以帮助我们更好的理解JVM生态和各自的作用，也可以帮助我们了解技术的发展

JVM类加载，个人理解就是Java类式怎么本加载过去的，想idea ide工具有通过这个进行开发，个人理解这个可以对自己进行自定义开发

JVM参数相关，常用参数是我们进行常用的工作的调试的力气

字节码：目前个人只是一个最粗浅的阶段，个人理解如入个门，别以后不认识



暂时的思考和总结在这里，其实在总结和写作的过程中也是思考和归纳的过程，中间也会产生很多新的疑问，不过暂时先到这

立个flag，有时间做个人博客，先用githubIO什么的，或许考虑上个云啥的

将自己对自己，对技术的思考写在上面，怎么说呢，如果针对于面试来说，都可以多一层筛选条件





## Java NIO

个人理解IO是操作系统的概念（不知道是不是计算机科学的概念，更加底层）

**自认为这里学的一般**

我们这里的Java IO和操作系统的IO貌似是不同层级的概念，但好像大差不差

IO主要分为对外部的IO设备的input/output

主要是对网络设备的网络IO，一个是磁盘设备的磁盘IO

目前的IO模型主要有4种IO模型

BIO，轮询的IO，多路复用的IO，信号驱动的IO，完全异步非阻塞的IO

理解这些IO首先要区分再这写模型种同步/非同步，阻塞/非阻塞的概念

同步/异步是相对于对操作系统的通信来说的，个人理解：向操作系统发出请求，不用管，让操作系统来通知你，这就是异步，目前只有最后一种IO模型支持，需要操作系统的支持，目前windows支持，但linux是使用的IO多路复用的模拟，JAVA的AIO就是这么调用的

阻塞非阻塞式针对于是线程来说的，但线程发起IO请求的时候，当没有资源的时候，是否线程一致阻塞，貌似编程中并不常用

四种IO模型个人理解各自都有优缺点，信号驱动的IO和AIO主要在于一个是操作系统通知IO执行完毕，一个是数据复制完毕

**暂时还没有详细的了解**，还有点懵

现在实际上的标准框架是Netty框架，Netty是基于Java的NIO做的，Java的NIO模型是基于多路复用的IO模型，从查到的资料显示主要是可以节省线程资源可以实现多连接

Netty框架隐蔽了NIO的复杂性，可以使用多种IO模型（跟复杂），并且基于各种各样实际上的问题提供了很多现成的解决方案



目前的理解如此



## 并发编程

多线程的本质是因为单核性能出现瓶颈（阿姆达尔定律代替了摩尔定律，不过这个其实也只是经验的出来的定律），所以需要使用到多个核心，线程是CPU调度的最小单位，我们在应用层面使用Java的多线程机制可以直接映射到操作系统的多线程机制，从这方面也体现了Java的跨平台性，

但多线程编写的程序引入提供了以前单线程编程的一种新的编程方式，同时页引入了多线程编程特有的可能导致的问题，这个暂时定义为多线程的问题，由于操作系统多线程的调度机制，个人理解本质就是当对同一个变量进行读写操作的时候不符合程序的预期，一个线程可能在运行的时候被随时中断，这样就有了多线程问题，这样就可能有一个问题，对于Java来说，或者对于变成来说，最小的操作指令是什么，就像世界上的原子一样，到达什么程度就是不可再分的，哈哈，这个可能扯远了

在这一领域有这样一个相关的概念就是**竞态条件，临界区，线程间通信，多线程**

个人觉得这个有理论支撑，不过自己暂时没做过太多的了解

是编程变得复杂，但是能够更加好得利用性能

Java种线程最基础得接口目前知道得有Runnable接口Callable接口和Thread类，个人理解所有得其他得都是基于此两个类来开发得来得

Java中的线程分为New，Terminal，Runnable（Ready，Running），waiting，Time-Wating，Block方法

可以通过多种方式进行线程状态的切换，可以查看思维导图->多线程->图一

与进程的调度管理由许多的相似之处

Java提供得操作线程的某几个基本方法主要分为继承自Object种的方法(wait,notify等等)，还有Thread类中的方法

个人理解之所以这么设计是由理论基础的，当然也可能由历史留下的东西

Object中的方法从目前来看主要是线程间的通信，Thread中的方法主要是线程的信息、启动等操作



以前我们讲异常都是单线程中的异常，但其实我们的编程方式可能最终还是要转到一种类似于多线程的方式，个人理解守护线程的存在就是这个一个道理，这里个人理解为人脑的局限和工程的局限导致

线程的异常可以自行处理，也可以抛出到另外一个线程来处理（主要用Future），值得注意的是当调用线程的Interrupt方法时，并不能直接中断，而是在线程执行处于阻塞状态才会被中断，个人理解这是一种规则，保护还是什么的，也有可能只能这么做，有待查证

对于多线程这样一种方式引入的新的编程问题就是多线程的安全问题，线程安全问题有3个特殊的性质，原子性、可见性、有序性

理解：原子性代表着操作指令不会被底层机制中断

​			可见性代表操作一个变量/数据能够理解被其他线程得知

​			有序性代表多线程的操作不受指令重排序，底层的乱序执行的影响（个人理解讨论有序性的时候那么一定要界定一个范围内来考虑），volatile修饰变量时变量具有的有序性（一定的有序性），个人理解就是他让变量的这一个操作，包括分配内存，初始化，建立引用这3个操作依然符合预期，JMM中定义了一套先行发生原则，与整个相关

目前编程常用的保证这几个性质的方式就是加锁

Synchronized，目前的理解仅仅限于有限的使用，资料中的线

程暂时还没有理解透彻，貌似对于不同领域的锁也有一套相关的理论

锁太多了

对象头标记等等

Volatile 能不能则不用，主要适用单线程写多线程读的场景（个人了解Atomic的一些工具有使用这些东西），每次读取都从主存中刷数据（会通知从主存中刷数据并且刷到工作内存），从个人的了解来看，主要有几个内存栅栏的东西，涉及到另外一个内存模型（主内存->工作内存->执行引擎），由于不太好把握整个关键字，推荐的使用规则时能不用就不用

final：由于其本身的特性（原生类型不可变，引用类型不可变引用，修饰方法不可重写，修饰类不可级成），而且能够保证可见性（个人觉得整个可见性其实就是前面的性质保证的）在多线程编程的时候，多使用final可以有效的提高多线程编码的可读性，减少bug发生的机率，是一个比较好的工程实践



### 线程池

我们自己创建线程固然简单，实践过程中，并不能无限次，无序的创建线程，线程资源在操作系统中时宝贵的资源，创建线程过多会面临频繁的上下文切换问题，个人理解从BIO切换到NIO就有这方面的考虑，Java提供了线程池工具包供给我们使用，现在主要使用的具体的工具体系包括 Executor，ExecutorService，ThreadFactory，ThreadPoolExecutor，Executors（与Executor类就像Collections与Collection关系一样）等，

ExecutorService提供了shutdown（），shutdownNow（），awaitTermination（）方法

提供了一种能够优雅的控制线程中断的方法

线程池的处理逻辑属于lazy的机制

并不会在创建的时候添加初始化好线程，而是在使用的时候才创建，以coreThread为阈值，否则加入等待队列，再不行执行拒绝策略

ThreadPool有一系列参数，corePoolSize，maximumPoolSize，ThreadFactory（目前了解来看主要是设置一些线程的名称什么的，感觉只是用来做这些东西），workQueue工作队列，用于缓冲线程对象的队列，目前暂不清楚实际的用途，可能对于大小优先级有一些作用，RejectedExecutionHandler，拒绝策略，目前主要有4中，1满则抛出异常，2丢弃最前，3丢弃最后，4交给父线程处理

固定线程池的设置经验

对于CPU密集型的应用，线程池大小设置N或者N+1

对于IO密集型型的应用，线程池大小设置为2N或2N+2

并不是一个系统都由一个线程池来管理，这样的话不灵活，个人理解如果设置一个很大的线程池其实相当于没设置，只设置一个固定的线程并不能跟随业务进行扩展

Exectors提供了常用的线程池的方法，具体包括：

固定一个的线程池**newSingleThreadExecutor**

固定大小的线程池**newFixedThreadPool**

可缓存的线程池 **newCachedThreadPool**

定时任务线程池**newScheduledThreadPool**

个人认为当涉及到多次调用的任务是可以优先考虑到使用线程池



### Callable

相对于Thread来说，Callable有返回值，这样就理解不用使用引用传递进行数据的处理，可以抛出异常

Callable主要与Future一起使用，用于支持异步的线程处理



这个要具体问题具体分析，Java提供了很多工具供我们使用

### java.util.concurrency

此包的分包结构式本包+Atomic包+Locks包

主要的并发相关包都在这里

目前自己对此包的方法并没有太多的实践，所以可能直接套用PPT的公式了

**Locks**

Locks提供了一种锁的相对于Synchronized的机制，使之能够更加的灵活，提供了中断，超时，异步处理锁的机制，且能够将是否加锁嵌入到编程中，目前并没有太多的理解，大概疑问就是如何将synchronized和Locks嵌入到编程理论中，个人理解一定有理论加持，然后就是我们通常所实践的其实式单线程编程，多线程并发编程据个人了解是一块大的编程领域了，这个有待解答

Locks与Synchroinzed对于我们来说只是一个标识，对JVM来说只是一个高级语言，怎么解释属于编译器的事情，JVM对这两个做了很多的优化，就性能来说，这两没太大区别

可重入锁意味着重复加锁：这个锁感觉好像还有一套理论和实践（联想到了MySQL的意向锁和排他锁的机制）

锁的公平非公平：公平意味着排队（非同优先级），非公平意味着同时争抢（同优先级），对于我来说还有点反直觉

读写分离：所也可以进行读写分离，**读锁**（共享，不排读锁）、**写锁**（不共享，排其他的锁）

可以通过生成Condition进行线程间的通信

**LockSupport**

LockSupport方法提供一种静态方法的控制锁的机制，比较像是反转控制



### 锁的最佳实践

个人理解锁的机制式为了解决并发安全的问题，多线程的问题主要来自于操作系统的可能对程序的中断加上不当的操作数据，如果只讨论基本类型，其实就是多线程对数据的读写不当，在过渡到类和相应的数据结构

应该尽可能的识别共享的变量是什么，应该如何进行通信和操作，粒度越小越好，这个其实个人理解像是多线程下的数据结构+算法了

#### Atomic

Atomic包主要适用于计数器等场景，采用了无锁技术，volatile变量和硬件提供的CAS指令

个人理解也是相当于底层硬件只是进行了更加细粒度的划分，细想下来貌似挺复杂的，涉及到指令是否原子的区别

始终乐观形式的处理资源竞争的思想

在竞争不太大比较适合，竞争太大可能大量占用CPU

### 并发工具类

并发工具类主要有**Semaphore** ：提供一种方便的控制类似信号灯资源的形式

**CountDownLatch**，提供超时的机制，主线程等待工作线程干完

**CyclicBarrier**，关注工作线程的同时执行

两者十分类似，但又不一样

个人觉得只是处于方便编程的方式考虑

毕竟，此3个工具类底层都是基于AQS进行的相关的实现



**FutureTask**

异步的线程的一种方式，能够等待

**CompletableFuture**

一种链式处理的方式，暂时还每台理解透彻

可传入回调对象的一种方式，将控制转给了别人，不再等待，可能等别人送给你



多线程的编程貌似还挺有趣的。。。



### Java中的数据结构和多线程相关

一般的数据结构如果不正当的使用容易引发类型安全的问题

比如ArrayList，LinkedList，**HashMap**

ArrayList常用的方法可以使用vector，可以使用Synchronized进行数据结构的包装

**CopyOnWriteArrayList**

对读的时候不用加锁，类似于一种副本的机制

**ConcurrentHashMap**

暂时不太懂，一种线程安全的map，相对于HashTable和SynchronizedHashmap性能更高，锁的粒度更小

**ThreadLocal**

方便得线程副本存放工具，知道这个明显可以偷懒

**Java8并行Stream**

方便的并行工具



##  Spring 和 ORM 等框架

### Spring

Spring发展到现在，从自己的视角来看，目前Spring已经无处不在了

Spring 是Java工程领域中非常重要，使用非常广泛的一个框架

他的创始人是位**音乐学博士**

Spring秉承一种依赖注入的设计思想，核心的组件功能主要包括Bean，Context和AOP

### Bean+Context

引入Spring后所有的技术，所有的功能都是一个一个的bean，基于Spring影响力和广泛的运用，一般的技术组件厂商比如Jedis，MongoDB等等都会开发出提供给Spring的Bean，相比于以前使用一门功能就new一个对象，由EJB集成的提供各种功能，Spring通过Bean，Context提供了一种更加轻量更加灵活的管理各种对象的方式

其实我理解也是面向对象的一种方式，但这个是提供了一种容器化的方案，使用bean进行组织起来，通过context来管理

不像以前一样随便new了，不过我可能没有以前的那种开发经验

通过Bean进行对各种功能进行各种功能的面向对象的组织，通过Context进行Bean的管理 ，自己也可以自定义bean，通过Xml注解各种方式进行Bean的注入和使用，通过引入Spring我们引入了一种声明式的编程方式，甚至改变了我们的团队的写作方式，对于工程团队来说引入Spring，也引入了一种协作方式

容器中的bean对象比较像一个Map

### AOP

Spring的AOP代理实现了接口的类直接使用的Java的动态代理机制

对于没有实现接口的类使用的CGlib直接操作的字节码

对于实现了接口的类使用Java Proxy进行代理

### Spring Boot

由于各种应用的发展，各种配置越来越复杂，但是一般来说其实都是某一种或某一个特定领域的方案，所以Spring的公司在Spring的基础上又抽象了一层，将各种常用的组件整合到了一起，提供了一种更为限定的框架解决方案，这时候可以被称为脚手架了

只需要一个引入各种Starter加上特定的注解，就能够更为轻松的创建出我们需要的应用

更像是形成了一个生态了（当平台和应用越来越成熟的时候，可能就形成了生态了）

Spring Boot的原理是基于Spring的

以前引入新的技术方案主要是XML配置，加上各种Jar包，然后可能需要自己配置参数

现在是通过Maven引入Jar包引入starter就行了，有各种**默认的配置**这是一种约定大于配置的思想，我理解其实就是大部分的配置适用于大多数的场景

如果需要自定义配置就只需要在相关的properties文件中修改就行了，不同的starter一般又不同的配置prefix

目前遇到个面试题：@SpringBootApplication中的注解有啥？答：@ComponentScan，@SpringBootConfiguration，@EnableAutoConfiguration

### ORM框架

ORM框架都是基于Java提供的JDBC接口

JDBC接口主要分为DriverManager，Connection，Statement，ResultSet，DataSourcePool（后续升级引入）

数据库厂商根据JDBC规范提供驱动包

由于直接使用JDBC不是很好操作，基于面向对象，于是出现了ORM的框架

ORM（Object-Relational Mapping）对象关系映射

主要是用对象来定义数据库中的实体Table，理论上来说数据库中的table也能够看作一个一个的对象

目前主要的框架为Hibernate和Mybatis

Hibernate没怎么用过，不过他可以不用写sql，直接用对象操作

Mybatis框架主要用来自己编写sql，这样相对来说更加的灵活



Spring通过事务管理器和AOP提供了一种生命式事务管理的形式

可以管理事务传播行为，超时，回滚，隔离级别，是否只读等属性

主要的方式是Transaction注解









## MySQL 数据库和 SQL

MySQL是开源的关系型数据库的一种，属于Oracle，有另外一个分支MariaDB，提供了在关系型数据库的通用能力

目前主要有5.6、5.7、8.0三个版本

他的体系结构主要分为server层+引擎层

server层主要提供连接，分析，优化，缓存等功能

引擎层，MySQL提供了引擎的接口规范，主要有InnoDB，MyISAM，Memory，Achive引擎

4个引擎中只有InnoDB支持事务，MyISAM引擎的数据量限制为256TB，InnoDB的数据限制为64TB，Memory引擎的数据主要用于内存数据，Achive的引擎容量大小没有限制

MySQL支持创建表的时候指定使用的引擎，可灵活运用

关系型数据库的基本操作时增删改查，针对于单个的操作的，主要需要讨论的问题时数据量，索引，事务，多个并发操作就需要考虑到锁了，锁分粒度，可到表和行，额外的还有数据压缩和外键



对于MySQL的操作，（单机情况下）主要在于功能和性能

目前主要使用的时InnoDB，在常见的场景中InnoDB能满足所有的需要，其提供的常用引擎中所有的功能

日常中，在经过确定的需求分析后，可考虑使用其他的引擎，否则使用innoDB一般没问题



工作中的使用主要是抽象出实体模型，确定好范式相关的东西，然后就是实际的字段设计了，在实际的细节涉及过程中需要考虑相关的数据类型，和一些约束like（id，主键，not Null default等等的操作），可根据具体的业务情况适当的合并实体或者添加冗余的字段，可能有时候可以考虑使用非InnoDB引擎，再数据量单机可以达到的情况下，可以考虑如何分区，分区考虑使用单字段分区或者多字段分区，再考虑设计索引，MySQL是索引组织表，考虑尽量不要回表且最左匹配且选择选择度高的字段进行索引的设计期间，这样一个完整的数据的设计就完成了

这是表层面相关的问题，具体的情况可以根据具体的业务细节加上掌握的知识情况进行设计，考虑到工程的交接，复杂度可自己把握，加上相应的文档设计

这是单个业务层面上的设计

再一个层面上就是数据库的配置了，数据库的配置暂时了解的不多，目前的理解是需要详细去了解各个参数的使用

主要分页server层的配置包括连接和缓存（8.0之前），然后就是引擎层的配置，这个理解主要是搜索，看文档然后实践和测试



 因为有了事务，        

## 分库分表

是因为资源的不够用

## RPC 和微服务

资源的不够用，单体架构变分布式架构，

## 分布式缓存

跟随分布式架构发展而来

## 分布式消息队列

跟随分布式架构发展而来，异步，削峰，解耦，可靠性传输，支持持久化消息





